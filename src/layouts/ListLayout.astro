---
/**
 * List Layout - For pages that display a list of items
 *
 * Usage in markdown:
 * ---
 * layout: ~/layouts/ListLayout.astro
 * title: "Talks"
 * view: timeline
 * items:
 *   - title: "My Talk"
 *     date: 2024-01-15
 * ---
 */

import BaseLayout from './BaseLayout.astro';
import ViewDispatcher from '../components/views/ViewDispatcher.astro';
import PreviewPanel from '../components/PreviewPanel.astro';
import { config } from '../lib/config';
import { getPageOptions } from '../lib/preview-options';

interface Props {
  frontmatter: {
    title: string;
    description?: string;
    view?: string;
    viewConfig?: Record<string, any>;
    items?: any[];
    groupBy?: string;
    showDate?: boolean;
    dateFormat?: string;
    showLinks?: string[];
    collection?: string;
    itemType?: string;
    [key: string]: any;
  };
}

const { frontmatter } = Astro.props;
const {
  title,
  description,
  view: defaultView = 'timeline',
  viewConfig = {},
  items = [],
} = frontmatter;

// Allow URL param to override view/style for preview mode
const urlView = Astro.url.searchParams.get('view');
const urlStyle = Astro.url.searchParams.get('style');
const view = urlView || defaultView;

const pageTitle = `${title} | ${config.site.title}`;

// Determine page type for preview panel
const pageType = frontmatter.itemType === 'talk' ? 'talks' :
                 frontmatter.collection === 'teaching' ? 'teaching' :
                 frontmatter.collection || 'items';

// Build viewConfig from frontmatter properties (URL params override)
const resolvedViewConfig = {
  ...viewConfig,
  style: urlStyle ?? frontmatter.style ?? viewConfig.style,
  groupBy: frontmatter.groupBy ?? viewConfig.groupBy,
  showDate: frontmatter.showDate ?? viewConfig.showDate,
  dateFormat: frontmatter.dateFormat ?? viewConfig.dateFormat,
  showLinks: frontmatter.showLinks ?? viewConfig.showLinks,
  showRole: frontmatter.showRole ?? viewConfig.showRole,
  showInstitution: frontmatter.showInstitution ?? viewConfig.showInstitution,
  showDescription: frontmatter.showDescription ?? viewConfig.showDescription,
};

// Transform items for ViewDispatcher
const transformedItems = items.map((item: any, index: number) => ({
  ...item,
  date: item.date ? new Date(item.date) : undefined,
  type: frontmatter.itemType || 'item',
  slug: item.slug || `item-${index}`,
}));
---

<BaseLayout title={pageTitle} description={description}>
  <article class="collection-page">
    <div class="container">
      <ViewDispatcher
        view={view}
        items={transformedItems}
        config={resolvedViewConfig}
        collection={frontmatter.collection || 'items'}
        title={title}
        description={description}
      />

      <div class="page-content">
        <slot />
      </div>

      {transformedItems.length === 0 && (
        <div class="empty-state">
          <p>No items to display yet.</p>
        </div>
      )}
    </div>
  </article>

  {import.meta.env.DEV && (
    <PreviewPanel
      pageType={pageType}
      options={getPageOptions(pageType)?.options || []}
    />
  )}
</BaseLayout>

<style>
  .page-content:not(:empty) {
    margin-top: var(--space-8);
  }

  .empty-state {
    text-align: center;
    padding: var(--space-12) var(--space-4);
    color: var(--color-text-muted);
  }
</style>

<script>
  document.addEventListener('preview-option-change', ((e: CustomEvent) => {
    const { option, value, pageType, requiresReload } = e.detail;

    // Only handle talks/teaching pages
    if (pageType !== 'talks' && pageType !== 'teaching') return;

    // Auto-reload is handled by PreviewPanel for requiresReload options
    if (requiresReload) return;

    // Toggle date visibility
    if (option === 'showDate') {
      document.querySelectorAll('.view-date, time, .item-date').forEach(el => {
        (el as HTMLElement).style.display = value ? '' : 'none';
      });
    }

    // Toggle description visibility
    if (option === 'showDescription') {
      document.querySelectorAll('.item-description, .view-description').forEach(el => {
        (el as HTMLElement).style.display = value ? '' : 'none';
      });
    }

    // Toggle context (event/location) visibility
    if (option === 'showContext') {
      document.querySelectorAll('.item-context, .view-context').forEach(el => {
        (el as HTMLElement).style.display = value ? '' : 'none';
      });
    }

    // Toggle role visibility
    if (option === 'showRole') {
      document.querySelectorAll('.item-role').forEach(el => {
        (el as HTMLElement).style.display = value ? '' : 'none';
      });
    }

    // Toggle institution visibility
    if (option === 'showInstitution') {
      document.querySelectorAll('.item-institution').forEach(el => {
        (el as HTMLElement).style.display = value ? '' : 'none';
      });
    }

    // Toggle tags visibility
    if (option === 'showTags') {
      document.querySelectorAll('.item-tags, .view-tags').forEach(el => {
        (el as HTMLElement).style.display = value ? '' : 'none';
      });
    }

    // Toggle type dots visibility
    if (option === 'showDot') {
      document.querySelectorAll('.view-dot, .type-dot').forEach(el => {
        (el as HTMLElement).style.display = value ? '' : 'none';
      });
    }

    // Group by changes
    if (option === 'groupBy') {
      const yearHeaders = document.querySelectorAll('.year-header, .timeline-year');
      yearHeaders.forEach(h => {
        (h as HTMLElement).style.display = value === 'year' ? '' : 'none';
      });
    }
  }) as EventListener);
</script>
